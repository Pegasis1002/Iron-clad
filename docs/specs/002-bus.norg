@document.meta
title: 002-bus
description: 
authors: dfg
categories: 
created: 2025-12-26T13:06:40+0530
updated: 2025-12-26T13:13:26+0530
version: 1.1.1
@end

* 1. Summary
  - The bus struct contains all storage devices(voletile and non-voletile).
  - Ram has a hard limit of 2^32 bits.
  - This computer only needs 128 MB of Ram.


* 2. Functional Requirements
  - 128 MB of Ram

* 3. Interface Definition
*** 3.2 RAM
    - Ram is defined as a Vector of 8-bit unsigned integers.

    @code rust
    struct BUS {
      ram: Vec<u8>,
      // Other interfaces.
    }
    @end

* 4. Methods
*** 4.1 Initialization
    - Set a hard limit on ram when initializing the struct.
    - RAM_SIZE = 128 * 1024 * 1024;

    @code rust
    let const RAM_SIZE: usize = 128 * 1024 * 1024;
    impl BUS {
      pub fn new() -> self {
        return self {
          ram: vec![u8; RAM_SIZE],
          // Other interfaces
        }
        // Other methods
      }
    }
    @end

*** 4.2 Read Word
    - Read 4 bytes from the memory
    - Combine them into a singular u32 instruction.
    - Keeping in mind Little-Endian convention(least significant byte first)
    - **Address Translation**: The input address is subtracted by `0x8000_0000` to map virtual address to physical RAM index.

    @code rust
    pub fn read_word(&self, addr: u32) -> u32 {
      let addr = (addr - 0x8000_0000) as usize;

      // Little-Endian
      let b0 = self.ram[addr] as u32;
      let b1 = self.ram[addr + 1] as u32;
      let b2 = self.ram[addr + 2] as u32;
      let b3 = self.ram[addr + 3] as u32;

      // Combine and return result
      return (b3 << 24) | (b2 << 16) | (b1 << 8) | b0;
    }
    @end

*** 4.3 Load Binary
    - Loads a binary file from the filesystem into the RAM.
    - Uses `std::fs::File` and `read` to populate `self.ram`.

    @code rust
    pub fn load_binary(&mut self, path: &str) -> std::io::Result<()> {
        let mut file = std::fs::File::open(path)?;
        let bytes_read = file.read(&mut self.ram)?;
        println!("INFO: Loaded {} bytes from {} into RAM", bytes_read, path);
        Ok(())
    }
    @end

*** 4.4 Write Word
    - Writes a 32-bit word to memory.
    - Splits the 32-bit integer into 4 bytes (Little-Endian).
    - Checks bounds to ensure the write is within the valid RAM range (starting at `0x8000_0000`).

    @code rust
    pub(crate) fn write(&mut self, addr: u32, data: u32) {
        let bytes = data.to_le_bytes();
        // Bounds checking logic...
        self.ram[index] = bytes[0];
        self.ram[index + 1] = bytes[1];
        self.ram[index + 2] = bytes[2];
        self.ram[index + 3] = bytes[3];
    }
    @end


* 7. Notes & Open Questions
- {Any miscellaneous notes, design trade-offs considered, 
questions that need to be resolved.}

